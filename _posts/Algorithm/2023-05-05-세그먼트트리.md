---
layout: post
title: "세그먼트 트리"
date: 2023-05-05
categories: algorithm
---

## 필요성
배열 `inputs`이 있을 때,
> 1. 배열의 구간 [L, R]사이의 연산(범위 내 있는 원소들의 합 구하기 등)하기.
> 2. 배열 `inputs`의 값을 변경하기.

위 두 연산을 하게 될 경우, (1)은 O(n), (2)는 O(1)의 시간이 소요된다.  
만일 위 연산을 m번 해야 할 경우 시간 복잡도는 최대 O(m*n)이다.  
입력 크기에 따라 위 방법으로는 시간 안에 문제를 해결하지 못할 수도 있다.  

물론 (1)의 문제만 있는 경우 메모이제이션 등 다양한 방법을 이용해 미리 계산을 해둘 수 있다. 이때 시간 복잡도는 O(n+m)이 될 것이다. 하지만 (2)의 상황까지 고려한다면 입력 숫자가 변경될 때마다 메모이제이션을 다시 해야 한다는 것을 알 수 있다. (1)과 (2)를 동시에 만족시키고자 한다면 역시 여전히 시간 복잡도는 최대 O(m*n)이 된다.

세그먼트 트리를 이용할 경우 (2)의 연산을 하는데 O(logn)의 시간이 소요되긴 하지만, (1)의 연산 역시 O(logn)의 시간에 수행할 수 있다. 

## 세그먼트 트리
루트 노드부터 시작해 해당 구간의 연산 결과를 저장한다. 왼쪽 서브 노드와 오른쪽 서브 노드는 루트 노드의 구간의 절반씩을 담당해 연산 결과를 저장한다. 이때 트리의 최하단 리프 노드는 1크기의 범위만 담당하게 되므로, 리프 노드에는 배열 `inputs`의 값이 직접 저장된다. 이는 재귀함수를 이용해 구현할 수 있다.

이때 노드의 수가 n이라고 한다면 
> 만들어지는 트리의 높이 `H=ceil(log(n))`이다.  
> 이때 필요한 세그먼트 트리의 배열 크기는 `2^(H+1)-1`개이다.

### 세그먼트 트리 초기 설정(백준 출처)

```c++
long long init(vector<long long> &inputs, vector<long long> &tree, int node, int start, int end) {
    if (start == end) {
        return tree[node] = inputs[start];
    } 
    else {
        return tree[node] = init(inputs, tree, node*2, start, (start+end)/2) + init(a, tree, node*2+1, (start+end)/2+1, end);
    }
}
```

세그먼트 트리의 초기 설정은 재귀적으로 해주는 것이 쉽다. start와 end가 동일해 진 경우엔 트리의 리프노드이므로 `tree[node]`에 `inputs`값을 대입해준다. 이 외의 경우엔 재귀적으로 왼쪽 서브 노드와 오른쪽 서브 노드의 결과를 처리해 현재 노드에 저장한다. 위 경우엔 왼쪽 서브 노드와 오른쪽 서브노드의 합을 저장해 현재 노드가 왼쪽 노드와 오른쪽 노드 전체 범위의 수의 합을 저장하도록 했다.

### 세그먼트 트리 값 탐색(백준 출처)

```c++
long long sum(vector<long long> &tree, int node, int start, int end, int left, int right) {
    if (left > end || right < start) {
        return 0;
    }
    if (left <= start && end <= right) {
        return tree[node];
    }
    return sum(tree, node*2, start, (start+end)/2, left, right) + sum(tree, node*2+1, (start+end)/2+1, end, left, right);
}
```
세그먼트 트리에서의 값 탐색 역시 재귀적으로 진행하면 쉽게 구할 수 있다. 이때 원하는 범위 `left`와 `right`, 현재 탐색중인 범위 `start`와 `end`의 관계는 다음 네가지중 하나이다.  
> 1. 현재 탐색중인 범위가 원하는 범위를 완전히 포함  
> 2. 원하는 범위가 현재 탐색중인 범위를 완전히 포함  
> 3. 두 범위가 전혀 겹치지 않음  
> 4. 그 외의 경우(일부만 겹침)  

이때 만일 (1)이나 (4)일 경우 탐색을 계속 이어나가면 된다. (2)일 경우 현재 탐색중인 범위는 원하는 범위에 모두 포함되기 때문에 세그먼트 트리에 저장된 값을 리턴해주고 해당 노드에서 자식노드로는 더는 탐색하지 않는다. (3)일 경우 탐색을 더 이상 이어나갈 필요가 없다. 구현 방식에 따라 세그먼트 트리에 저장된 값을 리턴해줘야 할 수도 있다.

### 세그먼트 트리 값 변경(백준 출처)

```c++
void update(vector<long long> &tree, int node, int start, int end, int index, long long diff) {
    if (index < start || index > end) return;
    tree[node] = tree[node] + diff;
    if (start != end) {
        update(tree,node*2, start, (start+end)/2, index, diff);
        update(tree,node*2+1, (start+end)/2+1, end, index, diff);
    }
}
```
위의 경우는 특정 인덱스의 값을 변경시키는 함수이다. 이때 세그먼트 트리에 저장된 값은 특정한 입력 원소를 저장한 것이 아닌 특정 범위에 대한 연산을 저장한 것이기 때문에 특정 인덱스를 포함하는 모든 범위에 대한 노드들을 변경시켜줄 필요가 있다. 위 구현에서는 변경 이전과 변경 이후의 차이를 `diff`에 저장한 후 변경을 원하는 인덱스를 포함하는 범위의 값들을 모두 변경시켜주었다. 이 경우 "두 범위가 전혀 겹치지 않음"에 해당하는 경우 가장 첫 줄에 기저사례로 탐색을 종료하도록 하였다. 만일 차이인 `diff`를 이용하지 않는다면, 세그먼트 트리의 리프 노드의 값을 직접 변경한 후, 부모노드는 이런 자식 노드들의 값을 재귀적으로 리턴받아 이를 이용해 다시 자신의 값을 수정하는 방식으로도 구현할 수 있을 것 같다. 이 경우엔 "전혀 겹치지 않음"의 경우에 세그먼트 트리에 저장된 값을 리턴하고 탐색을 종료해야 한다.
