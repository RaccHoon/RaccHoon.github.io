---
layout: post
title: "세그먼트 트리"
date: 2023-05-05
categories: algorithm
---

## 필요성
배열 `inputs`이 있을 때,
> 1. 배열의 구간 [L, R]사이의 연산(범위 내 있는 원소들의 합 구하기 등)하기.
> 2. 배열 `inputs`의 값을 변경하기.

위 두 연산을 하게 될 경우, (1)은 O(n), (2)는 O(1)의 시간이 소요된다.  
만일 위 연산을 m번 해야 할 경우 시간 복잡도는 최대 O(m*n)이다.  
입력 크기에 따라 위 방법으로는 시간 안에 문제를 해결하지 못할 수도 있다.  

물론 (1)의 문제만 있는 경우 메모이제이션 등 다양한 방법을 이용해 미리 계산을 해둘 수 있다. 이때 시간 복잡도는 O(n+m)이 될 것이다. 하지만 (2)의 상황까지 고려한다면 입력 숫자가 변경될 때마다 메모이제이션을 다시 해야 한다는 것을 알 수 있다. (1)과 (2)를 동시에 만족시키고자 한다면 역시 여전히 시간 복잡도는 최대 O(m*n)이 된다.

세그먼트 트리를 이용할 경우 (2)의 연산을 하는데 O(logn)의 시간이 소요되긴 하지만, (1)의 연산 역시 O(logn)의 시간에 수행할 수 있다. 

## 세그먼트 트리
루트 노드부터 시작해 해당 구간의 연산 결과를 저장한다. 왼쪽 서브 노드와 오른쪽 서브 노드는 루트 노드의 구간의 절반씩을 담당해 연산 결과를 저장한다. 이때 트리의 최하단 리프 노드는 1크기의 범위만 담당하게 되므로, 리프 노드에는 배열 `inputs`의 값이 직접 저장된다. 이는 재귀함수를 이용해 구현할 수 있다.

이때 노드의 수가 n이라고 한다면 
> 만들어지는 트리의 높이 `H=ceil(log(n))`이다.  
> 이때 필요한 세그먼트 트리의 배열 크기는 `2^(H+1)-1`개이다.

### 세그먼트 트리 초기 설정(백준 출처)
``` C++
long long init(vector<long long> &inputs, vector<long long> &tree, int node, int start, int end) {
    if (start == end) {
        return tree[node] = inputs[start];
    } 
    else {
        return tree[node] = init(inputs, tree, node*2, start, (start+end)/2) + init(a, tree, node*2+1, (start+end)/2+1, end);
    }
}
```
세그먼트 트리의 초기 설정은 재귀적으로 해주는 것이 쉽다. start와 end가 동일해 진 경우엔 트리의 리프노드이므로 `tree[node]`에 `inputs`값을 대입해준다. 이 외의 경우엔 재귀적으로 왼쪽 서브 노드와 오른쪽 서브 노드의 결과를 처리해 현재 노드에 저장한다. 위 경우엔 왼쪽 서브 노드와 오른쪽 서브노드의 합을 저장해 현재 노드가 왼쪽 노드와 오른쪽 노드 전체 범위의 수의 합을 저장하도록 했다.

### 세그먼트 트리 값 탐색(백준 출처)
```C++
long long sum(vector<long long> &tree, int node, int start, int end, int left, int right) {
    if (left > end || right < start) {
        return 0;
    }
    if (left <= start && end <= right) {
        return tree[node];
    }
    return sum(tree, node*2, start, (start+end)/2, left, right) + sum(tree, node*2+1, (start+end)/2+1, end, left, right);
}
```
