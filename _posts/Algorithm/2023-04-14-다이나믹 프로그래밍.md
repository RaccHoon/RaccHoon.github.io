---
layout: post
title: "다이나믹 프로그래밍 알고리즘 개념"
date: 2023-04-14
categories: algorithm
---

## 다이나믹 프로그래밍
다이나믹 프로그래밍의 기본 아이디어는 계산 결과를 메모리에 저장해 이후 같은 계산을 해야 할 때 빠르게 값을 구하는 방식으로 알고리즘의 동작 시간을 줄이는 것이다.  
당연히 메모리 제한을 고려해 문제를 해결해야 한다.  
다이나믹 프로그래밍의 관건은 무엇을 메모이제이션 할지 잘 고민해 최대한 많은 중복 문제를 만드는 것이다.  
중복문제를 많이 만들수록 DP는 더 좋은 성능을 보인다.

## c++에서의 배열 초기화 - memset()
`memset()`은 `cstring`에 정의 되어 있다.   
`memset()`함수를 이용해 배열을 0 또는 -1로 초기화 할 수 있다.  
`memset()`함수는 첫번째 인자로 배열의 시작 위치, 두번째 인자로 초기화 할 값, 세번째 인자로 변경하고자 하는 길이를 넘겨준다.  
이때 `memset()`함수는 배열의 각 바이트마다 초기화 할 값을 대입한다. 따라서 초기화 할 대상이 `char` 배열이 아닌 `int` 배열일 경우 문제가 발생할 수 있다.  
만일 초기화 하고자 하는 값이 0이거나 -1인 경우 각 바이트가 0000 0000 또는 1111 1111로 초기화 되기 때문에 결과적으로 0 또는 -1로 우연히 초기화 된다.  
```c++
#include <iostream>
#include <cstring>

using namespace std;

int main() {
     char arr[5][2];

    memset(arr, 'c', sizeof(arr));

    for(int i=0; i<5; i++) {
        for(int j=0; j<2; j++) {
            cout<<arr[i][j]<<" ";
        }
    }
}
```
> result: c c c c c c c c c c
`char`배열의 경우 어차피 각 요소가 1바이트기 때문에 `memset()`함수로 문제 없이 초기화 할 수 있다.

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main() {
     int arr[5][2];

    memset(arr, 1, sizeof(arr));

    for(int i=0; i<5; i++) {
        for(int j=0; j<2; j++) {
            cout<<arr[i][j]<<" ";
        }
    }
}
```
> result: 16843009 16843009 ....
`int` 배열의 경우 각 바이트가 초기화 할 값으로 채워진다. 위 예시에서 각 요소가 4바이트인 `int`배열은 각각의 값이 1로 초기화 되기 때문에 `00000001 00000001 00000001 00000001`로 초기화된다.  
따라서 16843009라는 값이 나오게 된다.

```c++
#include <iostream>
#include <cstring>

using namespace std;

int main() {
     int arr[5][2];

    memset(arr, 0, sizeof(arr));

    for(int i=0; i<5; i++) {
        for(int j=0; j<2; j++) {
            cout<<arr[i][j]<<" ";
        }
    }
}
```
> result: 0 0 0 0 0 0 0 0 0 0
`0` 또는 `-1`의 경우 각 바이트 값이 초기화 할 값으로 채워지더라도 `00000000 00000000 00000000 00000000` 또는 `11111111 11111111 11111111 11111111`로 초기화 된다.
이 값은 4바이트 정수에서도 `0` 또는 `-1`이 되기 때문에 원하는데로 초기화 할 수 있다.


결론적으로 `memset()`을 이용한 배열의 초기화는 배열이 char 배열이거나 초기화 하고자 하는 값이 0 또는 -1일 때만 이용하는 것이 바람직하다.  
`for`을 이용한 초기화가 아닌 `memset()`을 이용한 초기화의 장점은 속도에 있다.  
배열을 0이나 -1로 초기화 하는 경우는 매우 빈번하기 때문에 c++ 사용자들은 `memset()`을 이용해 배열을 쉽게 초기화 할 수 있다.

## 예제 문제 풀이 - N포커(baekjoon 16565)
[백준 N포커 문제 바로가기 / 다이나믹 프로그래밍 / 골드2](https://www.acmicpc.net/problem/16565)
약간의 수학적 지식이 필요한 문제였다. `<sub>n</sub>C<sub>r</sub>=<sub>n-1</sub>C<sub>r-1</sub>+<sub>n-1</sub>C<sub>r</sub>`라는 것을 알고 있다면 DP를 이용하여 풀 수 있다.
만약 포카드로 만들고자 하는 숫자가 `1`이라면 이때의 경우의 수는 `<sub>52-4</sub>C<sub>toPick-4</sub>`이다. 숫자는 `1~K`까지 13개이므로 앞의 경우의 수에 13을 곱해준다. 다만 이렇게 계산할 경우 선택할 카드의 개수가 8개 이상일 때 `1`이 포카드이면서 `2`가 포카드인 경우 등 포카드가 두번 나타나는 조합의 경우 두번 더해지게 된다. 그렇기 때문에 다시 `<sub>52-8</sub>C<sub>toPick-8</sub>`을 빼준다. 하지만 이렇게 계산하면 다시 포카드가 세번 나타나는 조합이 한번도 더해지지 않은 셈이 된다. 고등학교 확통 지식을 활용하면 손쉽게 알 수 있다. 이런식으로 반복되기 때문에 이를 고려해 코드를 작성해야 한다.
``` c++
#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>> cache(53, vector<int>(53, -1));

int combination(int total, int pick) {
    if(total==pick || pick==0) {
        return 1;
    }
    int& ret=cache[total][pick];
    if(ret!=-1) {
        return ret;
    }

    return ret=(combination(total-1, pick-1)+combination(total-1, pick))%10007;    
}

int main() {
    int cardNum;
    cin>>cardNum;

    int ret=0;
    for(int i=4; cardNum-i>=0; i+=4) {
        int currPick=i/4;
        if(currPick%2==1) {
            ret+=(combination(13, currPick)*combination(52-i, cardNum-i))%10007;
            ret%=10007;
        }
        else {
            ret-=(combination(13, currPick)*combination(52-i, cardNum-i))%10007;
            if(ret<0) {
                ret+=10007;
            }
        }
    }
    
    cout<<ret;
}
```
위 코드에서 조합 계산의 속도를 늘리기 위해 메모이제이션을 사용했다. 사실 조합론에 대한 지식은 없어도 그만이라 생각한다. 수학을 굳이 하고 싶지 않다면 다른 유형의 DP문제도 많이 있다.  
다만 조합 계산을 빠르게 하기 위해 DP를 사용하는 것은 굉장히 자주 등장하는 패턴이다.  